---
layout: default
title: 404 - Page Not Found
permalink: /404.html
---

<main role="main" class="nf-wrapper" aria-labelledby="nf-heading" aria-describedby="nf-text">
  <div class="nf-card">
    <div class="nf-emoji" aria-hidden="true">ðŸš€</div>
  <h1 id="nf-heading" class="nf-heading">404 â€“ Page <span id="rocket-typed-anchor"></span> Not Found</h1>
    <p id="nf-text" class="nf-text">This page drifted into space.</p>
    <div class="nf-actions">
      <a class="nf-btn primary" href="{{ site.baseurl }}/index.html">Home</a>
      <a class="nf-btn" href="{{ site.baseurl }}/blogs.html">Blog</a>
    </div>
  </div>
</main>

<script>
// Typed.js CDN
!function(){
  var s=document.createElement('script');
  s.src='https://cdn.jsdelivr.net/npm/typed.js@2.0.12';
  s.async=true; document.head.appendChild(s);
}();

// Interactive rocket flight on click
(function(){
  const rocket = document.querySelector('.nf-emoji');
  if(!rocket) return;
  const reduce = window.matchMedia('(prefers-reduced-motion: reduce)');
  let launched = false;
  let typedStarted = false;

  function startTypedInsertion(){
    if(typedStarted) return; typedStarted = true;
    const anchor = document.getElementById('rocket-typed-anchor');
    if(!anchor) return;
    const phrase = '(and also Rocket) ';
    function fallback(){ anchor.textContent = phrase; }
    // Wait for typed.js to load (poll a few times)
    let tries = 0;
    (function waitLib(){
      if(window.Typed){
        try {
          new window.Typed('#rocket-typed-anchor', {
            strings: [phrase],
            typeSpeed: 45,
            backSpeed: 0,
            showCursor: false,
          });
        } catch(e){ fallback(); }
      } else if(tries < 40){ // ~4s max
        tries++; setTimeout(waitLib, 100);
      } else { fallback(); }
    })();
  }
  rocket.style.cursor = 'pointer';
  rocket.setAttribute('role','button');
  rocket.setAttribute('tabindex','0');
  rocket.setAttribute('title','Launch the rocket');

  function random(min,max){ return Math.random()*(max-min)+min; }

  // No-motion variant: instant removal preserving layout for users preferring reduced motion.
  function launchNoMotion(){
    const rect = rocket.getBoundingClientRect();
    const placeholder = document.createElement('div');
    placeholder.style.height = rect.height + 'px';
    placeholder.style.marginBottom = '1.5rem';
    placeholder.className = 'nf-emoji-space';
    rocket.parentNode.insertBefore(placeholder, rocket);
    rocket.remove();
    startTypedInsertion();
  }

  function launchFancy(){
    const rect = rocket.getBoundingClientRect();
    const wrapper = document.createElement('div');
    // Placeholder keeps layout stable
    const placeholder = document.createElement('div');
    placeholder.style.height = rect.height + 'px';
    placeholder.style.marginBottom = '1.5rem';
    placeholder.className = 'nf-emoji-space';
    rocket.parentNode.insertBefore(placeholder, rocket);

    wrapper.style.position='fixed';
    wrapper.style.left = rect.left + 'px';
    wrapper.style.top = rect.top + 'px';
    wrapper.style.width = rect.width + 'px';
    wrapper.style.height = rect.height + 'px';
    wrapper.style.zIndex = 4000;
    wrapper.style.pointerEvents='none';
    wrapper.style.willChange = 'transform';
    rocket.parentNode.replaceChild(wrapper, rocket);
    wrapper.appendChild(rocket);
    rocket.style.animation='none';
    rocket.style.willChange='transform';

  const totalDuration = 3200; // ms for circular/spiral phase
  const rotations = 1.6;      // number of turns
  const maxRadius = Math.min(window.innerWidth, window.innerHeight) * 0.28; // spiral size
  const start = performance.now();
  let lastX = 0, lastY = 0;
  let prevX = 0, prevY = 0; // previous frame positions
  let lastVX = 0, lastVY = -1; // last velocity vector (default upward)
  let currentAngleDeg = 0; // track applied rotation

    function easeOutQuad(t){ return 1 - (1 - t) * (1 - t); }
  const BASE_EMOJI_NOSE_ANGLE = 45; // default ðŸš€ nose points ~45Â° (up-right) when rotation=0
  const INVERT = false; // set true if still tail-first

  function animate(now){
      const elapsed = now - start;
      let p = elapsed / totalDuration;
      if(p > 1) p = 1;

      // Smooth progression
      const prog = easeOutQuad(p);
      const theta = prog * rotations * Math.PI * 2; // angle
      const radius = prog * maxRadius; // spiral (grows over time)
      const x = radius * Math.cos(theta);
      const y = -radius * Math.sin(theta); // negative y -> upward
      // velocity
      if(elapsed === 0){ prevX = x; prevY = y; }
      const vx = x - prevX;
      const vy = y - prevY;
      if(Math.hypot(vx, vy) > 0.01){
        lastVX = vx; lastVY = vy;
      }
      prevX = x; prevY = y;
      lastX = x; lastY = y;
      wrapper.style.transform = `translate(${x}px, ${y}px)`;
      // angle so that 0deg means rocket points up; add 90deg because atan2 up gives -90deg
  const rawAngle = Math.atan2(lastVY, lastVX) * 180/Math.PI; // motion direction
  // Adjust so emoji nose (â‰ˆ45Â° at 0deg) aligns with motion; optionally invert if needed
  const adjust = (INVERT ? 180 : 0) - BASE_EMOJI_NOSE_ANGLE;
  const angleDeg = rawAngle + adjust;
  currentAngleDeg = angleDeg;
  rocket.style.transform = `rotate(${angleDeg}deg)`;

      if(p < 1){
        requestAnimationFrame(animate);
      } else {
        // Exit flight: diagonal up-right
  // Exit along current heading direction
  wrapper.style.transition = 'transform 2.1s cubic-bezier(.65,.05,.36,1), opacity 2.1s ease';
  rocket.style.transition = 'transform 2.1s cubic-bezier(.65,.05,.36,1)';
  // Compute nose direction from current rotation (rocket default pointing up)
  // Recompute direction vector from stored angle (inverse of above mapping)
  const travelAngleDeg = currentAngleDeg + BASE_EMOJI_NOSE_ANGLE - (INVERT ? 180 : 0);
  const travelTheta = travelAngleDeg * Math.PI/180;
  let dirX = Math.cos(travelTheta);
  let dirY = Math.sin(travelTheta);
  const mag = Math.hypot(dirX, dirY) || 1;
  dirX /= mag; dirY /= mag;
  // Encourage upward-ish exit if user ends pointing too downward
  if(dirY > 0.25){ dirY = -Math.abs(dirY); }
  const exitDist = Math.max(window.innerWidth, window.innerHeight) * 1.4;
  const exitX = lastX + dirX * exitDist;
  const exitY = lastY + dirY * exitDist;
  wrapper.style.transform = `translate(${exitX}px, ${exitY}px)`;
  rocket.style.transform = `rotate(${currentAngleDeg}deg) scale(1.22)`;
  wrapper.style.opacity = '0';
  setTimeout(()=> { wrapper.remove(); startTypedInsertion(); }, 2150);
      }
    }
    requestAnimationFrame(animate);
  }

  function handleLaunch(){
    if(launched) return; launched = true;
  if(reduce.matches) launchNoMotion(); else launchFancy();
  }

  rocket.addEventListener('click', handleLaunch);
  rocket.addEventListener('keydown', e => { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handleLaunch(); } });
})();
</script>
